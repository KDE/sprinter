= Curent milestone: 0.1

== Features
* Design and imlement an improved Plasma::QuerySyntax that is useful for:
    * run time help / hints for the user
    * automatic query construction
    * pre-threading query filtering
* Design and implement an improved (relative to krunner) "single runner" mode
* icons for QueryMatches
* add paging suppot to setMatches / updateMatches

== Improvements
* Clear all TODOs/FIXMEs in code
* QueryMatch::isSearchTerm should allow setting whether to only run against same runner that generated it (relies on a single-runner mode)

== Bugfixes
* Ensure all threads cleaned up before exit

= Next milestone: 0.2

== Features
* QueryMatch execution
    * Learning: record chosen QueryMatches, weight future matches with this information
* Pre-match() runner filtering
    * Based on:
        * Runner's advertised matching types
        * QuerySyntax
    * Controlled by:
        * A MatchType filter (from user, or UI component)
        * Query pre-processing?

== Improvements
* Improve RunnerSessionData::updateMatches
* Implement merging in setMatches

= Unscheduled
* Tiered match run priorities on runners set by the user
    * 0 - in worker thread; 1 launched first in threadpool; 2 launch last in threadpool
    * a launcher might request app launchers in tier 0, e.g.
* Query pre-processing (similar to Plasma::RunnerContext::Private::determineType)
    * this may actually be unecessary, or at least not as useful as was expected when krunner was in devel?
* Actions on matches
    * Could be done using QueryMatch::isSearchTerm to refine search?
* MatchType specializations
    * Allow QueryMatch to have a "free-form" QString that would represent an optional specialation to MatchType? (Only makes sense if this is a common requirement, as it incurs more overhead for all matches)
* Runner plugin test harness that "tortures" runners to see how they perform
    * Correctness of results
    * Threading safety
    * Speed
* Multiple query sesions in the same manager
    * This would allow one RunnerManager to be used from multiple UIs simultaneously
    * Requires multiplexing the RunnerSessionData (RSD) objects
    * Probably implement with a RAII class called e.g. SessionToken
        * Stores the RSD objects (RMT could touch its dptr)
        * Stores the query text
        * Stores the un-sync'd matches
        * Basically, all the data held by RMT goes here instead and RMT has a collection of SessionToken classes
        * RunnerSessionData, etc. are cleaned up in dtor
    * Would remove need for the QUuid sesion id in RMT