= Sprinter's Internal Thread Model

Three design requirements inform Sprinter's threading model:

    * the main application thread (MAT) should block as little as possible
    * runners should match in parallel
    * queries should be able to processed in a "as the user types" fashion

The threading model can be broken into four areas:

    * the main QuerySession worker thread
    * the RunnerSessionData thread
    * the Runner thread pool
    * the global thread pool

Objects that are passed between the threads are written to be thread-safe and  employ strategies such as copy-on-write semantics for cheap copying when needed and
to aid in thread synchronization. These classes include:

    * QueryContext
    * QueryMatch

= QuerySessionThread

The QuerySessionThread (QueST) is created, started and stopped by the QuerySession class. This is the most important, and complex, thread object in Sprinter. The QuerySession class lives in the MAT and so must do as little work as possible; the majority of this work is in servicing its requirements as a QAbstractItemModel, which in turn is driven directly by the application using it (usually the GUI itself). The rest of QuerySession's responsibilities simply pass work into the QueST.

The QueST itself manages the following tasks:

    * finding runner plugins
    * loading runners on demand
    * managing RunnerSessionData objects
    * launching match queries
    * executing matches
    * scheduling synchronization of matches

The vast bulk of this work happens outside the MAT. Besides construction and message passing into the thread, the only thing that the QueST does in the MAT is synchronize matches and provide access to the synchronized matches

The QueST is used by the runner model exported by QuerySession to advertise which runners are available, etc. This synchronization is done using signals and slots between the QueST and the runner model.

In QueST::run() it starts an event loop and then sets up the thread support. First it creates a timer used to start matching and a signal forwarder that lives in the thread itself. This signal forwarder serves to get requests from the QuerySession into the QueST thread: in Qt slots are run in the thread the object lives in. As the QueST necessarily lives in the MAT and only what happens in run() is actually in the thread, the signal forwarder simplifies the problem of getting actions to run in the thread even though triggered from the MAT.  It then finds the Runner plugins that exist and waits for queries.

When matches are generated by a Runner, the QueST will schedule a synchronization run. Syncronization happens in the MAT and moves whatever matches have not yet been synced from the Runner threads into the MAT over. This must happen in the MAT itself as it causes the QuerySession (which is a QAbstractItemModel) to update, which in turn causes the GUI to update.

To facilitate this, the QueST maintains a set of three QVectors:

    * one that contains the metadata on runner plugins, loaded or not.
      (See the RunnerMetaData class)
    * one that contains the loaded Runner plugins
    * one that contains the RunnerSessionData objects

These vectors are always the same size and the indexes correspond: the metadata at index 0 relates to the runner at index 0; the RunnerSessionData object at index 1 is for the Runner at index 1. This internal bookkeeping simplifies the code by relying on this set of assumptions.

= RunnerSessionData thread

On construction, the QueST creates a QThread with its own event loop for the RunnerSessionData objects. When a RunnerSessionData object is created, the QueST moves it to this RunnerSessionData thread.

This allows RunnerSessionData objects to continue processing events after Runner::match has been called without interfering with the QueST thread. Only after the RunnerSessionData object has been created and moved to the RunnerSessionData thread will its associated Runner be used for generating query matches.

= Runner thread pool

On construction, the QueST creates a QThreadPool used for jobs related to individual Runner tasks. This thread pool is refered to as the "Runner thread pool".

When a query starts, the QueST creates any missing RunnerSessionData objects. It does this by creating SessionDataRetriever objects that are run in the Runner thread pool. This allows Runners to create their session objects in parallel and for matching to start with Runners that return their session objects quickly without having to wait for slower Runners.

When a new query is started, a MatchRunnable is created for the next Runner in the vector and sent to the Runner thread pool for execution. One can view the Runner vector as being treated much like a circular buffer: when a new query starts, it is not the first Runner in the vector that gets the request, but the next Runner; or put another way: the least used Runner always gets first crack at a new query term. This continues until all the Runners in the vector have processed the query term. If the query term changes, the process continues but with the "stop point" reset to the most recently used Runner.

= Global thread pool

When a match is requested for execution, an ExecRunnable is created which contains a copy of the QueryMatch object. This runnable is sent to the application global thread pool for execution, away from all the other work that may be ongoing in the QueST, RunnerSessionData thread and RunnerThreadPool. The theory here is to try and ensure that when the user requests a match to be started, it does so immediately no matter how busy the query matching apparatus still is.